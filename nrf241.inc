#IFNDEF nrf241
#DEFINE nrf241

#IFNDEF 	nrf24L01_DEF
#INCLUDE 	nrf24L01_DEF.INC
#ENDIF

;*********************************************************************************************;
NRF_SUBROUTINES		CODE	;0x31B
;*********************************************************************************************;
;*********************************************************************************************;
LIST	
; FLUSH THE BUFFERS
FLUSH_ALL
		FARCALL	NRF_FLUSH_RX
		FARCALL	NRF_FLUSH_TX
		FARCALL	READ_ALL_NRF
		FARCALL	NRF_CLR_ALL_INTERRUPTS
		FARCALL	NRF_ENTER_RCV_MODE
	RETURN


WREG_TO_UTON_BUFFER
		BANKSEL	TEMP1
		MOVWF	TEMP1
		FARCALL		SAFE_UTON_BUFF_APPEND	
	RETURN

STRING_TO_NRF_XT 
		CLRF		BK_INDEX_REG			;INDEXER
XT_MSG_LOOP
		MOVFW		BK_INDEX_REG
		FARCALL		GET_BYTE_W_FROM_TABLE		; NEED TO BE A CALL TO GIVE RETLW SOMEPLACE TO GO
		BANKSEL		TEMP1
		MOVWF		TEMP1
		FARCALL		SAFE_UTON_BUFF_APPEND
		INCF		BK_INDEX_REG
		XORLW	0X03		
		SKIP_IF_ZERO						; END OF TRANSMISSION?
		GOTO		XT_MSG_LOOP				; GOTO MSG_LOOP. ADJUST AFTER EDITING THIS CODE
		FARCALL		NRF_DATA_HANDLER
	RETURN								;YES. DONE

 ;LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
;	FUNCTION: HEXTONRF
;	DESCRIPTION: OUTPUTS THE VALUE OF WREG TO THE NRF TRANSMITTER, FORMATTED AS A HEXIDECIMAL VALUE
;	AFFECTS: W, STATUS, HEX2UARTREG
;LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
HEXTONRF:
		GLOBAL	HEXTOUART
		BANKSEL	HEX2UARTREG
		MOVWF	HEX2UARTREG
		FARCALL	HEXTONRF_PREFIX

		BANKSEL	HEX2UARTREG
		MOVFW	HEX2UARTREG
		FARCALL	HEXTONRF_RAW
		FARCALL	CR_LF_TO_NRF	
	RETURN	
	
HEXTONRF_PREFIX
		MOVLW	"0"
		FARCALL	WREG_TO_UTON_BUFFER
		MOVLW	"x"
		FARCALL	WREG_TO_UTON_BUFFER
	RETURN

HEXTONRF_RAW
		BANKSEL	HEX2UARTREG
		MOVWF	HEX2UARTREG
		BANKSEL	HEX2UARTREG
		SWAPF	HEX2UARTREG, 0		;HI NIBBLE
		FARCALL	HEXTOASC
		FARCALL	WREG_TO_UTON_BUFFER
	
		BANKSEL	HEX2UARTREG
		MOVFW	HEX2UARTREG
		FARCALL	HEXTOASC
		FARCALL	WREG_TO_UTON_BUFFER
	RETURN

		
CR_LF_TO_NRF	
		MOVLW	0X0A				; NEW LINE
		FARCALL	WREG_TO_UTON_BUFFER		
		MOVLW	0X0D				; CARRIAGE RETURN
		FARCALL	WREG_TO_UTON_BUFFER
		
	RETURN
;*********************************************************************************************;

;*********************************************************************************************;
NRF_CODE	CODE	;0X800
;****************************************************************************
;org 0x300
;****************************************************************************
; Function: NRFIntISR
;
; PreCondition: None
;
; Overview:
;       This is a Interrupt service routine for an NRF Interrupt.
;       It handles Reception of received data (RX_DR), notice of Transmission of data complete,
;		and notification of transmission failure (MAX_RT).
;       Called from Interrupt service routine
;
; Input: none
;
; Output:   If data is received it puts it in NtoU_BUFFER and accordingly
;       adjusts the N2UBufRdPtr and clears N2UBE flag.
;       If Receive Buffer becomes full then it will set N2UBF
;       bit. If data is received when Receive buffer was full it will
;       set NtoUBufOF flag to indicate that transmitted data has
;       been missed because of full UART_TO_NRF_BUFFER. If any error is
;       generated in reception it will set NtoUError flag bit.
;
;       If last data is transmitted then it will transmit next pending
;       data if any. It will accordingly adjust the NtoU_BUF_DATA_CNT. It
;       will clear the UARTIntTxBufFul bit to indicate space for data in
;       NtoU_BUFFER.
;
; Side Effects: Databank, W, STATUS changed
;
; Stack requirement: 1 level deep
;
;****************************************************************************
NRFIntISR:
; This code  develops a vector from the 3 possible interrupt flags in the NRF's STATUS register.
;	DONT EDIT THIS CODE. BEFORE COMPLETELY UNDERSTANDING WHAT IT IS DOING!!!
;*****************************************************************************
POLLING_VECTOR_ROUTINE
		FARCALL		NRFGetStatus				; SEE WHAT'S UP WITH THE NRF...
		MOVLW		HIGH(INT_VECTORS)
		MOVWF		PCLATH
		BANKSEL		NRF_STATUS
		SWAPF		NRF_STATUS, W			; PUTS BITS 6,5, AND 4 AT 2, 1, AND 0
		ANDLW		SWAPPED_NRF_INT_FLAG_MASK 	; ELIMINATE HI NIBBLE AND BIT 3
		ADDWF		PCL							; JUMP AHEAD TO INTERRUPT VECTOR
INT_VECTORS
NO_INTERRUPT						; NO INTERRUPTS INDICATED :-/
		GOTO		NO_INTERRUPT_SR		; W = B'0000... NO INTERRUPT WAS SET.
MAX_RETRIES							; 
		GOTO 		MAX_RT_SR		; W = B'0001... MAX_RT BIT 0 WAS SET
TX_DATA_SENT_OK						; SUCCESS! 
		GOTO		TX_DS_SR		; W = B'0010...	TX_DS, W = B'0010
		GOTO 		MAX_RT_SR		; W = B'0011... MAX_RT BIT 0 WAS SET. SERVICE IT FIRST
RECIEVED_DATA						
		GOTO		RX_DR_SR		; W = B'0100...	YOU HAVE MAIL. :-)

INTERRUPT_EXCEPTIONS
		RESET	;GOTO	RX_DR_SR			; W = B'0101... Both MAX_RT_INT_ISR and RECIEVED_DATA. Not likely, but get the received data
		RESET	;GOTO	TX_DS_SR			; W = B'0101... Both MAX_RT_INT_ISR and TX_DS_INT_ISR. Not likely, but get the received data
		RESET	;GOTO	RX_DR_SR			; W = B'0111... MEANS ALL THREE FLAGS WERE SET.  Get the recieved data first.
		RESET	;GOTO 	NO_INTERRUPT_SR		; W = B'1000? 	NO INTERRUPT WAS SET.

UNKNOWN_ISR_INT		; SHOULD NEVER GET HERE. 
		BANKSEL	NRF_STATE_REG
		BSF		NRF_STATE_REG, UNKNOWN_INTERRUPT
		FARCALL	NRFGetStatus				; SEE WHAT'S UP WITH THE NRF...
		nop
;		goto	$-1					; if it ever gets here in debug, something is wrong!
		GOTO	LEAVE_NRF_INT

END_OF_POLLING_VECTOR_ROUTINE
; 	END OF POLLING VECTOR ROUTINE
;	CODE BELOW CAN BE EDITED
;********************************************************************************************;
;********************************************************************************************;
NO_INTERRUPT_SR
		BCF	 INTCON,	INTF		; (Any Bank) clear the portB:0-caused interrupt.
		BANKSEL	PORTB
		BTFSC	PORTB, RB0
		GOTO	LEAVE_NRF_INT
		BTFSS	INTCON,	INTF		; (Any Bank) clear the portB:0-caused interrupt.
		FARCALL	PRINTF_UNKNOWN_FAILURE
		GOTO	LEAVE_NRF_INT
;------------------------------------------------------------------------------
;------------------------------------------------------------------------------

;********************************************************************************************;
;********************************************************************************************;
MAX_RT_SR
#IFDEF REPORT_MAX_RT	
		m_IMMEDIATE_PRINTF MAX_RT
#ENDIF
		BANKSEL	NRF_STATE_REG
		BSF		NRF_STATE_REG, MAX_RT_ISR_BIT
		BCF		NRF_STATE_REG, TX_IN_PROGRESS

;	CLEAR THE INTERRUPT FLAG
		BANKSEL	REGVAL
		MOVlw	MAX_RT_FLAG_MASK		; B'00010000'
		MOVWF	REGVAL
		MOVLW	RF_STATUS
		FARCALL	WT_REGVAL_TO_NRF_REG_W			; Bit's 3:0 are read only, Bits 6:4 are "Write 1 to clear bit."

		m_RD_NRF_REG	OBSERVE_TX,	NRF_OBSERVE_TX	; MIGHT USE THIS IN FUTURE TO ADJUST POWER SETTINGS
		FARCALL	NRF_FLUSH_TX	; FLUSTH THE FIFO BECAUSE APARRENTLY, "If the auto retransmit counter 
								; (ARC_CNT) exceeds the programmed maximum limit(ARC), the MAX_RT bit in 
								; the STATUS register is set high. The payload in TX FIFO is NOT removed.

	RETURN
;********************************************************************************************;
;	TX_DS_SR: CALLED UPON COMPLETION OF A SUCCESSFUL TRANSMISSION/RECEPTION/ACK
;	DESC:	CLEARS THE TX_DS FLAG, CHECKS THE XMIT FIFO AND THE UTON_BUFFER STATUS
;			UPDATES THE NRF_STATE_REG
;********************************************************************************************;
TX_DS_SR
#IFDEF REPORT_TX_SUCCESS
		m_IMMEDIATE_PRINTF TX_SUCCESS
#ENDIF
;	CLEAR THE TX_DS FLAG IN THE STATUS REGISTER
		MOVlw		TX_DS_FLAG_MASK		; B'00100000'
		BANKSEL		REGVAL
		MOVWF		REGVAL
		MOVLW		RF_STATUS
		FARCALL		WT_REGVAL_TO_NRF_REG_W			; Bit's 3:0 are read only, Bits 6:4 are "Write 1 to clear bit."

		BANKSEL		NRF_STATE_REG						; 
		BCF			NRF_STATE_REG,	TX_IN_PROGRESS 		; BUFFER AND TX FIFO are EMPTY. CLEAR THE TX_IN_PROGRESS BIT 3

		BANKSEL		NRF_FIFO_STATUS
		BTFSS		NRF_FIFO_STATUS, TX_FIFO_EMPTY	; IS THE NRF TX FIFO EMPTY?
		GOTO		NRF_XMIT_NOT_DONE				; NO. MORE TRANSMITTING STILL TO DO.
		
		BANKSEL		NRF_STATE_REG				
		BTFSS		NUUNBUFSTAT,	U2NBE			; IS THE BUFFER EMPTY? (Bit 1 = 1)
		GOTO		NRF_XMIT_NOT_DONE				; NO. MORE TRANSMITTING STILL TO DO.
		
		BANKSEL		UTON_BUF_DATA_CNT
		MOVF		UTON_BUF_DATA_CNT,	F

		BTFSC		STATUS,	Z							;	UPDATE THE NRF_STATE_REG
		RETURN		; BUFFER AND TX FIFO are EMPTY. DONE.

NRF_XMIT_NOT_DONE		
		BANKSEL		NRF_STATE_REG						; 
		BSF			NRF_STATE_REG,	TX_IN_PROGRESS 		; BUFFER is NOT EMPTY!... UN-CLEAR THE TX_IN_PROGRESS BIT 3
		BSF			NRF_STATE_REG, 	TX_DS_ISR_BIT	
		FARCALL	NRFGetStatus		
 RETURN											; NO. KEEP BEING A TRANSMITTER				


;********************************************************************************************;
;	RX_DR_SR: CALLED UPON RECEPTION OF A PACKET OF DATA
RX_DR_SR:
		BANKSEL		NRF_STATE_REG				
		BSF			NRF_STATE_REG, 	RX_DR_ISR_BIT

#IFDEF REPORT_DATA_RECEIVED
		m_IMMEDIATE_PRINTF RECIEVER_DR
#ENDIF
;	CLEAR THE INTERRUPT FLAG
		BANKSEL	REGVAL
		MOVlw	RX_DR_FLAG_MASK		; B'01000000'
		MOVWF	REGVAL
		MOVLW	RF_STATUS
		FARCALL	WT_REGVAL_TO_NRF_REG_W			; Bit's 3:0 are read only, Bits 6:4 are "Write 1 to clear bit."
		
		FARCALL	NRF_GET_DATA			; YES. READ AND WRITE IT TO THE UART
			
		RETURN
;********************************************************************************************;
		
		
;********************************************************************************************;
;LEAVE_NRF_INT:	ANY NFR INTERRUPT SHOULD LEAD TO HERE. HOUSEKEEPING.
;********************************************************************************************;
LEAVE_NRF_INT
;		bcf			INTCON,	INTF		; (Any Bank) clear the portB:0-caused interrupt.
		RETURN
;LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL


;LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
;			RECEIVER FUNCTIONs
;LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
;***********************************************************************;
; NRF_ENTER_RCV_MODE: Set the CONFIG bit PRIM_RX.
;***********************************************************************;
NRF_CHECK_RCV_MODE
		m_RD_NRF_REG	CONFIG, NRF_CONFIG	;CONFIGURATION REGISTER
		BTFSC	NRF_CONFIG,	PRIM_RX			; IF IT'S A ZERO, IT'S A PTX
	return								; OTHERWISE, NOTHING TO DO
		
		
NRF_ENTER_RCV_MODE
		CE_LO							; FORCE TO STANDBY MODE...DE-ACTIVATE TX/RX			
NEEDS_ADJUSTMENT		
		m_RD_NRF_REG	CONFIG, NRF_CONFIG	;CONFIGURATION REGISTER
		IORLW			0X01			; SET THE PRX/PTX BIT0
		FARCALL		WTW_NRF_REG_CONFIG
		MOVLW	0X04
		FARCALL 	W_X_100uS_DELAY			; Tstby2a	Standby modes -> TX/RX mode MIN = 130µs
		CE_HI						; DE-ACTIVATE TX/RX
	RETURN


	
;LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
;	FUNCTION: NRF_GET_DATA
;	DESCRIPTION: TRANSFERS Payload data FROM THE NRF TO THE NtoUBuffer
;				 	All non-empty pipelines (FIFOS) are read and their data is written to the NtoUBuffer
;LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
NRF_GET_DATA:
; "The RX_DR IRQ is asserted by a new packet arrival event. The procedure for handling this interrupt should
;	be: 	1) read payload through SPI, 
;			2) clear RX_DR IRQ, 
;			3) read FIFO_STATUS to check if there are more payloads available in RX FIFO, 
;			4) if there are more data in RX FIFO, repeat from step 1)."
;LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
	CE_LO							; DE-ACTIVATE TX/RX
		FARCALL	NRFGetStatus			; > READ NRF STATUS REGISTER TO DETERMINE ACTIVE_PIPELINE, AND WHETHER THERE IS STILL DATA TO RETRIEVE
		ANDLW	RX_P_NO_MASK			;	First mask off all irrelevant bits with b'00001110'
		BANKSEL ACTIVE_PIPE
		MOVWF	ACTIVE_PIPE
		XORLW	RX_P_NO_MASK			; then see if it equals 111
		SKIP_NOT_ZERO					; ZERO INDICATES THE RX_FIFO IS EMPTY
		GOTO	PAYLOAD_READ_DONE	; Housekeep and return
;1) read payload through SPI,
		FARCALL	NRF_GET_ONE_PAYLOAD		; EMPTY OUT ONE PIPELINE
;2) clear RX_DR IRQ	
PAYLOAD_READ_DONE
		MOVLW			0X40			;\
		m_WTW_NRF_REG		RF_STATUS		; > CLEAR THE RX_DR INTERRUPT										
		m_RD_NRF_REG		RF_STATUS, NRF_STATUS
;3) read FIFO_STATUS to check if there are more payloads available in RX FIFO,
		m_RD_NRF_REG	FIFO_STATUS,	NRF_FIFO_STATUS	; 
		BANKSEL		NRF_FIFO_STATUS
		BTFSS		NRF_FIFO_STATUS,	RX_EMPTY		; IS RX FIFO Empty?
;4) if there are more data in RX FIFO, repeat from step 1)."
		GOTO		NRF_GET_DATA	
		CE_HI			; ACTIVATE TX/RX
		BANKSEL		NRF_STATE_REG				
		BCF			NRF_STATE_REG, 	RX_DR_ISR_BIT
	RETURN
;LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL

LIST	
;LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
;	;	FUNCTION: NRF_GET_ONE_PIPE
;		DESCRIPTION: Reads the Payload of one pipeline, and places 
;					  it in the NtoUBuffer
;LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
NRF_GET_ONE_PAYLOAD

		BCF		INTCON,	INTE		; DON'T WANT INTERRUPTS IN THE MIDDLE OF THE COMMAND
; FIND OUT WHAT THE PAYLOADS WIDTH IS
; AND STORE IN COUNT_REG FOR LOOP CONTROL
		m_RD_NRF_REG	R_RX_PL_WID, COUNT_REG		; Quick check to make sure there is valid data
		SKIP_IF_ZERO		
		GOTO	R_RX_PL_WID_NOT_ZERO
		retlw	0x0

R_RX_PL_WID_NOT_ZERO
		sublw	.32					;	CHECK to see if the data length exceeds 32 bytes.
		btfsc	STATUS,	C			;	if it doesN'T
		GOTO	PAYLOAD_SIZE_VALID	; PAYLOAD SIZE IS VALID
		FARCALL	FLUSH_RX_FIFO 		; flush the pipes and return
;		BSF		INTCON,	INTE		;
		retlw	0x0
				
PAYLOAD_SIZE_VALID		
; ALL SYSTEMS GO. CLOCK THE PAYLOAD FROM NRF TO PIC
		BANKSEL	PORTC
		BCF	  	PORTC, 2	
		MOVLW		R_RX_PAYLOAD		;\
		FARCALL		SPI_TRANSFER		; \INITIATE TRANSFER

NRF_GET_ONE_PIPE_LOOP
		RD_NRF_BYTE	

#ifdef STATISTICS
		BANKSEL		BYTE_COUNT_FROM_NRF
		INCF		BYTE_COUNT_FROM_NRF
		BTFSC		STATUS,	Z
		INCF		BYTE_COUNT_FROM_NRF+1
#endif
							; GET A BYTE FROM THE RX_PLD_BUFFER
		FARCALL		UARTIntPutCh			; OUT A CHAR IN THE UART TX BUFFER
		BANKSEL		COUNT_REG				; 
		DECFSZ		COUNT_REG				; 
		GOTO		NRF_GET_ONE_PIPE_LOOP	; REPEAT
		CSN_HI						;			

		BANKSEL		NUUNBUFSTAT
		BTFSS		NUUNBUFSTAT,	N2UBOF	;See if NtoUBuffer OVERFLOWED
		RETURN	
		BANKSEL		NRF_STATE_REG
		BSF			NRF_STATE_REG,	NRF_RX_FIFO_OF
		RETURN		
;LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL

;LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
;	FUNCTION: FLUSH_RX_FIFO				
;	DESCRIPTION: EMPTIES THE NRF'S RECEIVE FIFO PIPELINES
;	AFFECTS:	WREG, STATUS, SSPBUF, NRF_STATE_REG
;LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
FLUSH_RX_FIFO				; SHOULD NOT GET HERE OFTEN!
		MOVLW	FLUSH_RX	 ;\
		BANKSEL	PORTC
		BCF	  	PORTC, 2	
		FARCALL	SPI_TRANSFER ;/
		CSN_HI
		BANKSEL	NRF_STATE_REG
		BSF		NRF_STATE_REG,	NRF_RX_FIFO_OF
#ifdef REPORT_RX_FIFO_OVERFLOW
		FARCALL	PRINTF_RX_FIFO_OVERFLOW
#ENDIF
		RETURN


;LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
;	TRANSMITTER FUNCTIONS 
;TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT

;***********************************************************************;
;	XMIT_UTON_BUF_DATA
;	FUNCTION: 	TOP-LEVEL NRF TRANSMIT COMMAND
;		SUB FUNCTIONS CALLED:
;			"NRF_ENTER_XMIT_MODE" ....... SETS NRF TO TRANSMIITER MODE
;			"XFER_BUF_DATA_TO_NRF" ...... MOVES DATA FROM THE PIC TO THE NRF
;			"COMMENCE_PACKET_TRANSMISSION" .... WHAT IT SAYS IT DOES
;
;	
;***********************************************************************;
XMIT_UTON_BUF_DATA
;---->	Other setup operations to put here: adjust TX_ADDR...
		BANKSEL	NUUNBUFSTAT
		BTFSC	NUUNBUFSTAT, U2NBE
		RETURN
		FARCALL 	NRF_ENTER_XMIT_MODE		; set PRIM_RX Low, leave CE low and delay for 130uS		
		FARCALL		XFER_BUF_DATA_TO_NRF	; NOW write the BUFFER data into the fifo ;;;;;;;;;;;;;;;;;;;
		FARCALL		COMMENCE_PACKET_TRANSMISSION
	RETURN
;TTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTT

;//////////// ////////////////////////////////////////////////////////////////
; NRF_ENTER_XMIT_MODE: Clear the CONFIG bit PRIM_RX.
;//////////// ////////////////////////////////////////////////////////////////
NRF_ENTER_XMIT_MODE:		
		m_RD_NRF_REG	CONFIG,		NRF_CONFIG 
		BTFSS		NRF_CONFIG,	PRIM_RX
			RETURN
		CE_LO								; FIRST GO TO STANDBY MODE...DE-ACTIVATE TX/RX
		m_RD_NRF_REG	CONFIG, NRF_CONFIG	; READ THE CONFIGURATION REGISTER, THEN
		ANDLW			B'01111110' 		; CLEAR THE PRIM_RX BIT AND RESERVED BIT 7
		FARCALL			WTW_NRF_REG_CONFIG
;		m_WTW_NRF_REG	CONFIG				; AND WRITE IT BACK TO NRF
;		m_RD_NRF_REG	CONFIG, NRF_CONFIG	; READ THE CONFIGURATION REGISTER, THEN
  RETURN
;//////////////////////////////////////////////////////////////////
TRANSFER_NEW_PAYLOAD			;	GOOD.
		FARCALL		XFER_BUF_DATA_TO_NRF	; Write the BUFFER data into the fifo.
TRANSMIT_LOADED_DATA
		FARCALL		COMMENCE_PACKET_TRANSMISSION
	RETURN
;//////////////////////////////////////////////////////////////////

;//////////// ////////////////////////////////////////////////////////////////
;	FUCTION: COMMENCE_PACKET_TRANSMISSION
;	DESC:	CAUSES THE NRF TO TRANSMIT THE DATA CONTENTS OF ONE FIFO PIPE.
; //////////////////////////////////////////////////////////////////////////////////////////// 
COMMENCE_PACKET_TRANSMISSION:		;;;;;;;;;;;	BLAST---OFFFFFFF! ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
#IFDEF STATISTICS
		banksel		COMMENCE_XMIT_COUNTER
		incfSZ		COMMENCE_XMIT_COUNTER+1
		goto		$+2
		INCF		COMMENCE_XMIT_COUNTER
#ENDIF
		CE_HI										;TRANSMIT THE PACKET BY SETTING CE HI. (MINIMUM 10µS)
		movlw	2
		FARCALL	W_X_10uS_DELAY
		CE_LO										;TRANSMIT THE PACKET BY SETTING CE HI. (MINIMUM 10µS)
		
		BANKSEL		NRF_STATE_REG
		BSF			NRF_STATE_REG, TX_IN_PROGRESS		; AT THIS POINT, THE COMMUNICATION SHLOULD BE TAKING PLACE
#IFDEF STATISTICS
		banksel		TX_IN_PROGRESS_SET
		incfsz		TX_IN_PROGRESS_SET+1
		goto		$+2
		INCF		TX_IN_PROGRESS_SET
#ENDIF		
 RETURN


INITIATE_TX_PAYLOAD_WT	;;;;;;;;;;;;;;;send the write to payload command;;;;;;;;;;;;;;;;;;;;
		BANKSEL	PORTC
		BCF	  	PORTC, 2		; SELECT THE CHIP	
		MOVLW	W_TX_PAYLOAD	; INITIATE TX PAYLOAD TRANSFER
		FARCALL	SPI_TRANSFER	; AND SEND IT
	RETURN

;LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
;	FUCTION: XFER_BUF_DATA_TO_NRF
;	DESC:	WRITES UP TO 32 BYTES OF DATA FROM THE UTON BUFFER TO THE NRF CHIP.
;			IF THE BUFFER GOES EMPTY, OR IF IT REACHES THE 32 BYTE LIMIT, IT RETURNS TO CALLING FUNCTION
;	PREREQUISITE: NRF HAS RECEIVED A TX_PAYLOAD OR W_TX_PAYLOAD_NOACK COMMAND
;LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
XFER_BUF_DATA_TO_NRF:
		BANKSEL	DATA_SIZE			;\
		MOVLW	MAX_PAYLOAD_BYTES	; > SETUP
		MOVWF	DATA_SIZE			;/
;//////////////////////////////////////////////
		FARCALL		INITIATE_TX_PAYLOAD_WT			; SEND THE COMMAND TO LOAD THE TX PIPELINE
PUT_TX_BYTE_LOOP 
		BANKSEL	NUUNBUFSTAT
		BTFSC	NUUNBUFSTAT,	U2NBE				; IS BUFFER EMPTY? (UARTIntGetCh sets this bit)
     	GOTO	TRASFER_COMPLETE					; no more data. RETURN

        banksel UTON_BUF_DATA_CNT
        movf    UTON_BUF_DATA_CNT,W
        btfsc   STATUS,Z                			;Check if data is availabe in Rx buf
     	GOTO	TRASFER_COMPLETE					; no more data. RETURN

		FARCALL	UARTIntGetCh						;	get a byte from the UtoN Buffer INTO W.
#IFDEF STATISTICS
		BANKSEL	BYTE_COUNT_TO_NRF					; track # of bytes sent. should match	
		INCF	BYTE_COUNT_TO_NRF					; record # of bytes received in the LSByte. If it rolls over,
		BTFSC	STATUS,	Z							; it didn't. Dont increment the MSByte ..........
		INCF	BYTE_COUNT_TO_NRF+1					; it did. Increment the MSByte ..........
#ENDIF
		FARCALL	SPI_TRANSFER						; NO. DATA IS GOOD, TRANSFER IT TO NRF
		
		BANKSEL	DATA_SIZE
		DECFSZ	DATA_SIZE							; IF THIS HITS ZERO, GOTTA LAUNCH
		GOTO	PUT_TX_BYTE_LOOP					; NO. TRANSFER ANOTHER BYTE, IF AVAILABLE IN BUFFER
TRASFER_COMPLETE
		CSN_HI										; THE TRANSFER IS COMPLETED.
 RETURN
;LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
		
;LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
; PULSE_CE: THIS TRIGGERS A TRANSMISSION
;	PULSE MUST BE > 10uS, per mfg spec.
;LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
PULSE_CE
	CE_HI				;
	MOVLW	D'30'
	FARCALL	W_X_1uS_DELAY
	BANKSEL	PORTC
	CE_LO	
 RETURN
;LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL

		
;LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
;	COMMON NRF FUNCTIONS
;LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL

;LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
;	FUCTION: CLEAR_STATUS_INTERRUPT_FLAGS
;	DESC:	CLEARS ALL INTERRUPT FLAGS IN THE NRF STATUS REGISTER.
;LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
CLEAR_STATUS_INTERRUPT_FLAGS:
		MOVLW	0X70
		m_WTW_NRF_REG		RF_STATUS 		
 RETURN

		
;*****************************************************************************
;	NRF_READ_REG_NO_FSR_MODIFY: Read a register in the NRF chip
;	PREREQ: NRF_STORE_REG_ADD MUST CONTAIN THE FILE REGISTER THAT STORES THE VALUE READ
;			RF24_COMMAND MUST CONTAIN THE REGISTER ADDRESS OF THE NRF THAT IS TO BE READ
;			FSR1 MUST BE INITIALIZED FOR THE DESTINATION STORAGE
;	Stores the result in the corresponding NRF_XXX pic register
;	Also updates the NRF_STATUS pic register
;	Affects: FILE IT POINTS TO, WREG, STATUS. RETURNS VALUE IN THE WREG 
;*****************************************************************************
NRF_READ_REG_NO_FSR_MODIFY
			BANKSEL		PORTC
			BCF	  		PORTC, 2					;CSN_LO	SELECT THE CHIP
			BANKSEL		RF24_COMMAND
			MOVFW		RF24_COMMAND
			FARCALL		SPI_TRANSFER		; SEND THE COMMAND
			BANKSEL		NRF_STATUS		; 
			MOVWF		NRF_STATUS		; Log Status Register
			MOVLW		NRF_NOP				; ENTER DUMMY BYTE TO TRANSFER DATA FROM NRF
			FARCALL		SPI_TRANSFER		; AND READ IT
			BANKISEL	NRF_CONFIG			; 
			MOVWF		INDF1				; LOG REGISTER DATA
			CSN_HI							; TERMINATE SPI TRANSFER
	RETURN

;*****************************************************************************
;	FUNCTION: NRFGetStatus
;	DESC:	GETS THE CONTENTS OF THE NRF'S STATUS REGISTER
;			AND PLACES IT IN THE NRF_STATUS GPR
;*****************************************************************************
NRFGetStatus:
		movlw	NRF_NOP
		CSN_LO
		FARCALL	SPI_TRANSFER
		BANKSEL	NRF_STATUS
		MOVWF	NRF_STATUS
		CSN_HI
	Return
;*****************************************************************************

;*****************************************************************************
;	SUB_NRF_READ_REG: Read a register in the NRF chip
;	PREREQ: NRF_STORE_REG_ADD MUST CONTAIN THE FILE REGISTER THAT STORES THE VALUE READ
;			RF24_COMMAND MUST CONTAIN THE REGISTER ADDRESS OF THE NRF THAT IS TO BE READ
;	Stores the result in the corresponding NRF_XXX pic register
;	Also updates the NRF_STATUS pic register
;	Affects: FSR1 AND FILE IT POINTS TO, WREG, STATUS. RETURNS VALUE IN THE WREG 
;*****************************************************************************
SUB_NRF_READ_REG
		BANKSEL		NRF_STORE_REG_ADD
		MOVFW		NRF_STORE_REG_ADD	;
		MOVWF		FSR1					; FSR1 SHOULD NOW BE POINTING TO THE RIGHT REGISTER
		BANKSEL		RF24_COMMAND
		MOVFW		RF24_COMMAND
		CALL		SUB_NRF_READ_REG_W_TO_FSR
	RETURN


;*****************************************************************************
;	NRF_RD_REG_W: Read a register in the NRF chip
;	PREREQ: WREG MUST CONTAIN THE REGISTER ADDRESS OF THE NRF THAT IS TO BE READ
;	RETURNS: NRF REGISTER'S VALUE IN WREG
;	Affects: WREG, STATUS. RETURNS VALUE IN THE WREG 
;*****************************************************************************
NRF_RD_REG_W
		CSN_LO
		FARCALL		SPI_TRANSFER		; SEND THE COMMAND
		BANKSEL		NRF_STATUS			; 
		MOVWF		NRF_STATUS			; Log Status Register
		MOVLW		NRF_NOP				; ENTER DUMMY BYTE TO TRANSFER DATA FROM NRF
		FARCALL		SPI_TRANSFER		; AND READ IT
		CSN_HI							; TERMINATE SPI TRANSFER
	RETURN


;*******************************************************************
;	FUNCTION:	SUB_NRF_READ_REG_W_TO_FSR
;	ALTERNATE WAY TO READ THE NRF REGISTERS AND STORE THE RESULT IN THE PIC SHADOW REGISTERS
;	PREREQ: CALL THIS ROUTINE IF: 	THE WREG HAS THE RD_COMMAND FOR THE NRF REGISTER
;									FSR1 IS BOINTING TO THE NRF SHADOW REGISTER
;*******************************************************************
SUB_NRF_READ_REG_W_TO_FSR				 
		CSN_LO
		FARCALL		SPI_TRANSFER		; SEND THE COMMAND
		BANKSEL		NRF_STATUS		; 
		MOVWF		NRF_STATUS		; Log Status Register
		MOVLW		NRF_NOP				; ENTER DUMMY BYTE TO TRANSFER DATA FROM NRF
		FARCALL		SPI_TRANSFER		; AND READ IT
		MOVWF		INDF1				; LOG REGISTER DATA
		CSN_HI							; TERMINATE SPI TRANSFER
	RETURN

RESET_NRF
		m_RD_NRF_REG	CONFIG, NRF_CONFIG			;READ THE CONFIGURATION REGISTER, THEN
		ANDLW			B'01111101' 	; CLEAR the PWR_UP BIT AND THE RESERVED BIT 7
		BANKSEL			NRF_CONFIG		;
		MOVWF			NRF_CONFIG		; LOG IT IN THE PICS LOG REGISTER
;		m_WTW_NRF_REG	CONFIG		; AND WRITE IT BACK TO NRF
		FARCALL			WTW_NRF_REG_CONFIG
;		m_RD_NRF_REG	CONFIG, NRF_CONFIG			;READ THE CONFIGURATION REGISTER, THEN
		FARCALL	NRF_PWR_UP
	RETURN


NRF_PWR_UP
		m_RD_NRF_REG	CONFIG, NRF_CONFIG			;READ THE CONFIGURATION REGISTER, THEN
		ANDLW			B'01111111' 	;CLEAR THE RESERVED BIT 7
		IORLW			B'00000010'		;AND SET THE PWR_UP BIT
		BANKSEL			NRF_CONFIG		;
		MOVWF			NRF_CONFIG		; LOG IT IN THE PICS LOG REGISTER
		FARCALL		WTW_NRF_REG_CONFIG
;		m_WTW_NRF_REG	CONFIG		; AND WRITE IT BACK TO NRF
;		m_RD_NRF_REG	CONFIG, NRF_CONFIG			;READ THE CONFIGURATION REGISTER, THEN
	RETURN


;*********************************************************************************************;
NRF_FLUSH_RX
		BANKSEL	PORTC
		BCF	  	PORTC, 2	
		MOVLW	FLUSH_RX
		FARCALL	SPI_TRANSFER
		CSN_HI
	RETURN
;*********************************************************************************************;
	
;*********************************************************************************************;
NRF_FLUSH_TX
		BANKSEL	PORTC
		BCF	  	PORTC, 2	
		MOVLW	FLUSH_TX
		FARCALL	SPI_TRANSFER
		CSN_HI
		MOVLW			0X70		;\
		m_WTW_NRF_REG		RF_STATUS	; > CLEAR THE INTERRUPTS
	RETURN
;*********************************************************************************************;

;*********************************************************************************************;
NRF_CLR_ALL_INTERRUPTS
		CE_LO				; Standby-I mode...DE-ACTIVATE TX/RX
		MOVLW			0X70
		m_WTW_NRF_REG		RF_STATUS		; CLEAR INTERRUPT MASKS, Bits 6:4	
	RETURN
;*********************************************************************************************;


;LLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLL
;	READ_RANGE_NRF_II
;START START START START START START START START START START START START START START START START START START START
READ_RANGE_NRF_II
    READ_RANGE_NRF_II_LOOP
	    FARCALL		Get_Nrf_Address
	    BANKSEL		RF24_COMMAND
	    MOVWF		RF24_COMMAND
	    FARCALL		GET_SHADOW_REG
	    BANKSEL		FSR1L
	    MOVWF		FSR1L
	    FARCALL		NRF_READ_REG_NO_FSR_MODIFY
	    INCF		TABLE_POSITION_PTR
	    MOVFW		CONFIG_ARG_2
	    XORWF		TABLE_POSITION_PTR, W
	    BTFSS		STATUS,	Z
	    GOTO		READ_RANGE_NRF_II_LOOP
      RETURN

	    Get_Nrf_Address
		   	MOVLW		HIGH NRF_REG_MAP_START
			MOVWF		PCLATH					;BL_REG_PCLATH	
		
			BANKSEL	NRF_REG_MAP_START    	
		    MOVLW		NRF_REG_MAP_START	
		    ADDWF		TABLE_POSITION_PTR,W
		    BTFSC		STATUS,C
		    INCF		PCLATH
		    MOVWF		PCL
	     RETURN

    GET_SHADOW_REG
	MOVLW		HIGH NRF_SHADOW_MAP_START
	MOVWF		PCLATH					;BL_REG_PCLATH	
	BANKSEL		NRF_SHADOW_MAP_START
	MOVLW		NRF_SHADOW_MAP_START
	ADDWF		TABLE_POSITION_PTR,W
	BTFSC		STATUS,C
	INCF		PCLATH
	MOVWF		PCL

 ;	READ_RANGE_NRF_II
;END END END END END END END END END END END END END END END END END END END END END END END END END END END END END 


;***********************************************************************;
READ_ALL_NRF
;***********************************************************************;
		CLRF	TABLE_POSITION_PTR	;\
		MOVLW	0XC					; > OBSOLETE, USE "READ_RANGE_NRF_II" FOR MORE FLEXIBILITY
		MOVWF	CONFIG_ARG_2		;/
		FARCALL	READ_RANGE_NRF_II
		
		FARCALL	READ_ALL_MULTIBYT_REGISTERS
		
		MOVLW	0XC	
		MOVWF	TABLE_POSITION_PTR
		MOVLW	0X15
		MOVWF	CONFIG_ARG_2
		FARCALL	READ_RANGE_NRF_II

 	RETURN
;***********************************************************************;
;	END OF READ_ALL_NRF
;***********************************************************************;


;***********************************************************************;
;	READ THE MULTI-BYTE ADDRESSES
;**START*********************************************************************;
READ_ALL_MULTIBYT_REGISTERS
	MOVLW	3
	MOVWF	CONFIG_ARG_2
READ_ALL_NRMR_LOOP
		
	MOVLW	5						; #OF BYTES TO READ
	MOVWF	COUNT_REG				; FOR THE LOOP

	MOVLW	HIGH tbl_MULTI_BYTE_NRF_SHADOW_REGS	;\
	MOVWF	BL_REG_PCLATH						; \
	MOVLW	tbl_MULTI_BYTE_NRF_SHADOW_REGS		;  > GET THE TABLE LOCATION OF THE TABLE
	MOVWF	TBL_START_PTR					; /
	DECF	CONFIG_ARG_2						;
	MOVFW	CONFIG_ARG_2						;
	FARCALL	GET_BYTE_W_FROM_TABLE				;	GO GET THE SHADOW REGISTER POINTER
	ADDWF	COUNT_REG,W
	MOVWF	FSR1L						; FOR INDERECT ADDRESSING (FSR1 IS DECREMENTED 
									;		IN THE SUB PRIOR TO WRITING THE INDF1

	MOVLW	HIGH tbl_MULTI_BYTE_NRF_REGISTERS	;\
	MOVWF	BL_REG_PCLATH								; \
	MOVLW	tbl_MULTI_BYTE_NRF_REGISTERS		;  > GET THE TABLE LOCATION OF THE TABLE
	MOVWF	TBL_START_PTR					; /
	MOVFW	CONFIG_ARG_2						;
	FARCALL	GET_BYTE_W_FROM_TABLE				;	GO GET A READ COMMAND 

	NOP		; AT THIS POINT, WE SHOULD HAVE THE SHADOW REG ADDRESS IN THE FSR1,	'4' IN THE COUNT_REG, AND THE NRF COMMAND IN THE WREG
	FARCALL	NRF_READ_MULTIBYTE_REG				;	READ AND STORE THE VALUES 
	INCF	CONFIG_ARG_2
	DECFSZ	CONFIG_ARG_2
	GOTO	READ_ALL_NRMR_LOOP	
  RETURN
;**END*OF*;	READ THE MULTI-BYTE ADDRESSES***************************;
;***********************************************************************;


;***********************************************************************;
;	FUNCTION: NRF_READ_MULTIBYTE_REG	
;	DESCRIPTION:	INITIATES THE WREG COMMAND BY WRITING INTO THE NRF 
;					TO READ MILIPTLE BYTE REGISTERS IN THE NRF. STORES 
;					SUCH AS THE RF ADDRESSES. STORES RESULT IN SHADOW REG
;	PREREQUISITE:	WREG MUST HAVE THE READ/ADDRESS.
;					FSR1 MUST HAVE THE HIGH ADDRESS OF THE SHADOW REG
;
;	EXAMPLE USAGE:	MOVLW	5						; #OF BYTES TO READ
;					MOVWF	COUNT_REG				; FOR THE LOOP
;					ADDLW	NRF_TX_ADDR				; THE HIGH ADDRESS OF THE SHADOW REGISTER
;					MOVWF	FSR1						; FOR INDERECT ADDRESSING (FSR1 IS DECREMENTED 
;													;		IN THE SUB PRIOR TO WRITING THE INDF1
;					MOVLW	TX_ADDR					; REGISTER READ COMMAND,
;					CALL	NRF_RD_MLTY_BYTE_REG	; 
;					
;					
;					
;***********************************************************************;
NRF_READ_MULTIBYTE_REG	
   	CSN_LO						;CSN_LO();	
	FARCALL		SPI_TRANSFER		; SEND THE COMMAND
NRMR_LOOP
	MOVLW		0XFF			; JUST FOR CLOCKING...
	FARCALL		SPI_TRANSFER	; GET A BYTE
;	CLRF		FSR1H			;
	DECF		FSR1L				;
	MOVWF		INDF1			;	 
	DECFSZ		COUNT_REG		; AND REPEAT LEN-1 TIMES
	GOTO		NRMR_LOOP		; WHILE_LEN		;//
   	CSN_HI						;DONE. UN-ASSERT CSN_HI();	
 RETURN


s_CSN_LO
		BANKSEL	PORTC
		BCF	  	PORTC, 2	
	RETURN


READ_NEXT_NRF_REG
	BANKSEL	LAST_NRF_INDEX
	MOVFW	LAST_NRF_INDEX
	INCF	LAST_NRF_INDEX
	BANKSEL	TABLE_POSITION_PTR
	MOVWF	TABLE_POSITION_PTR

	MOVLW	LOW NRF_SHADOW_MAP_START
	MOVWF	TBL_START_PTR
	MOVLW	HIGH NRF_SHADOW_MAP_START
	MOVWF	BL_REG_PCLATH	
	FARCALL	GET_TABLE_BYTE
	MOVWF	FSR1L

	MOVLW	LOW NRF_REG_MAP_START
	MOVWF	TBL_START_PTR
	MOVLW	HIGH NRF_REG_MAP_START
	MOVWF	BL_REG_PCLATH	
	FARCALL	GET_TABLE_BYTE

	FARCALL	SUB_NRF_READ_REG_W_TO_FSR
	
	BANKSEL	LAST_NRF_INDEX
	MOVFW	LAST_NRF_INDEX	
	XORLW	0XC
	BTFSC	STATUS,Z
	CLRF	LAST_NRF_INDEX
 RETURN
	
	
	
;RD_NRF_REG	FIFO_STATUS,	NRF_FIFO_STATUS		; IS THE FIFO EMPTY?
;	
;RD_NRF_REG  MACRO 		RD_NRF_REG_CMD_ADD,	NRF_STORE_REG
;			BANKSEL		NRF_CONFIG
;			MOVFW		RF24_COMMAND
;			ADDLW		0X30
;			MOVWF		NRF_STORE_REG_ADD
;			XORLW		NRF_RPD
;			BTFSS		STATUS,	Z			IS IT 
;			GOTO		NOT_NRF_RPD
;					
;NOT_NRF_RPD
;			MOVLW		NRF_STORE_REG
;			MOVWF		NRF_STORE_REG_ADD		
;			BANKSEL		NRF_STORE_REG	
;		FARCALL 	SUB_NRF_READ_REG


;*********************************************************************************************;
;	FUNCTION: WT_REGVAL_TO_NRF_REG_W	
;	DESC:		LOADS NRF REGISTER POINTED AT BY WREG WITH THE DATA IN REGVAL
;	PREREQ: 	REGVAL LOADED WITH VALUE, WREG LOADEDWITH ADDRESS
;	AFFECTS:	WREG, NRF_STATUS, 
;*********************************************************************************************;
WT_REGVAL_TO_NRF_REG_W
		CSN_LO
		ADDLW		WRITE_REG		; 0X20 + REGADDRESS CAUSES RIGHT TO THAT NRF ADDRESS
		FARCALL		SPI_TRANSFER	; SEND THE WRITE TO NRF_REG COMMAND
		BANKSEL		NRF_STATUS		;
		MOVWF		NRF_STATUS		; NRF ALWAYS SENDS THE STATUS REGISTER VALUE AS THE 1ST BYTE
		BANKSEL		REGVAL			;
		MOVFW		REGVAL			; GET THE DATA TO WRITE
		FARCALL		SPI_TRANSFER	; CLOCK IN THE DATA
		CSN_HI
	RETURN

;*********************************************************************************************;
;	FUNCTION: 	WTW_NRF_REG_CONFIG	
;	DESC:		WRITES CONTENTS OF WREG TO THE NRF CONFIG REGISTER.
;	PREREQ: 	WREG LOADED WITH CONFIG VALUE TO BE WRITTEN
;	AFFECTS:	FSR1, WREG, REGVAL, NRF_CONFIG, NRF_STATUS
;	USES:		WT_REGVAL_TO_NRF_REG_W, SPI_TRANSFER
;*********************************************************************************************;
WTW_NRF_REG_CONFIG		
		BANKSEL		REGVAL			
		MOVWF		REGVAL					; TEMPORARILY STORE W HERE
		MOVLW		NRF_CONFIG					
		MOVWF		FSR1
		MOVLW		CONFIG					; DESIGNATE REGISTER ADDRESS (THE AAAAA)
		FARCALL		WT_REGVAL_TO_NRF_REG_W
		MOVLW		CONFIG					; DESIGNATE REGISTER ADDRESS (THE AAAAA)
		FARCALL		SUB_NRF_READ_REG_W_TO_FSR
	RETURN



;ORG 0XBD0
NRF_INIT CODE	;0X7A8
;*********************************************************************************************;
;*********************************************************************************************;
;	NRF24L01_INIT: This function should always be called at startup. It performs the following:
;		1) Allows time for the NRF to stabilize after power is applied
;		2) After 100mS, NRF is in Power Down mode. 
;		3) Sets the PWR_UP bit, Puts the NRF into standby mode
;		4) Configures the registers for frequency, addresses, bit rate, crc, auto-acknowledge, dynaymic payloads, etc.
;		5) Sets the NRF into PRIM_RX mode
;*********************************************************************************************;
;***********************************************
NRF24L01_INIT
		movlw	D'20'				; first, wait at least 100mS for the NRF to power on
		FARCALL	W_x_10mS_DELAY		; now mode = PowerDown
	
		FARCALL	RESET_NRF
		movlw	2					; now, wait 10mS for the crystal to start up
		FARCALL	W_x_10mS_DELAY		; Tpd2stby= Ls/30mH *1.5ms

		FARCALL	NRF_PWR_UP			; SET THE PWR_UP BIT IN THE CONFIG REGISTER
		movlw	2					; now, wait 10mS for the crystal to start up
		FARCALL	W_x_10mS_DELAY		; Tpd2stby= Ls/30mH *1.5ms
;		NRF IS NOW IN STANDBY-I MODE.
									
;**********************************************
;NRF24L01_SETUP	transmitter setup
;**********************************************

; All paramaters are stored in, and read from, the eeprom.		
	m_EEPROM_TO_NRF_REG	EE_CONFIG,		CONFIG,		NRF_CONFIG			; 
	m_EEPROM_TO_NRF_REG	EE_EN_AA,		EN_AA,		NRF_EN_AA			;SET UP AUTO-ACKNOWLEDGE ENABLE FOR EACH PIPE
	m_EEPROM_TO_NRF_REG	EE_EN_RXADDR,	EN_RXADDR,	NRF_EN_RXADDR		;SET UP ENABLING RX ADDRESSES FOR EACH PIPE
	m_EEPROM_TO_NRF_REG	EE_SETUP_AW,	SETUP_AW,	NRF_SETUP_AW		;SET UP ADDRESS WIDTHS
	m_EEPROM_TO_NRF_REG	EE_SETUP_RETR,	SETUP_RETR,	NRF_SETUP_RETR		;RE-TRANSMIT SETUP RETRYS
	m_EEPROM_TO_NRF_REG	EE_RF_CH,		RF_CH,		NRF_RF_CH			;SET THE RF CHANNEL. VALUE MUST BE BETWEEN 0 AND 127, INCLUSIVE
	m_EEPROM_TO_NRF_REG	EE_RF_SETUP,	RF_SETUP,	NRF_RF_SETUP		;RF_SETUP REGISTER---SET UP DATA RATE AND POWER LEVE

; STATUS REGISTER
		FARCALL	NRF_CLR_ALL_INTERRUPTS					;	
		m_RD_NRF_REG		RF_STATUS,	NRF_STATUS		; 	READ ONLY		
		
; READ-ONLY REGISTERS		
		m_RD_NRF_REG		OBSERVE_TX,	NRF_OBSERVE_TX 		;READ ONLY, TRANSMIT OBSERVE REGISTER
		m_RD_NRF_REG		RPD,	NRF_RPD					;Received Power Detector.(BIT 0)
	
	NOP
	CONFIG_ADDRESS	TX_ADDR, 	EE_TX_ADD_0, 	EE_TX_ADD_1, 	EE_TX_ADD_2, 	EE_TX_ADD_3, 	EE_TX_ADD_4, RP10 	 			;AS 3-5 BYTES WITH ALL 0XEF
RP10	;	RETURN POINT
	CSN_HI
	CONFIG_ADDRESS	RX_ADDR_P0, EE_RXP0_ADD_0, 	EE_RXP0_ADD_1, 	EE_RXP0_ADD_2, 	EE_RXP0_ADD_3, 	EE_RXP0_ADD_4, RP2 	 ;FOR RX PIPES 0 AND 1 ONLY. AS 3-5 BYTES WITH ALL 0XEF
RP2
	CSN_HI
	CONFIG_ADDRESS RX_ADDR_P1, 	EE_RXP1_ADD_0, 	EE_RXPx_ADD_1, 	EE_RXPx_ADD_2, 	EE_RXPx_ADD_3,	EE_RXPx_ADD_4, RP3 	 ;FOR RX PIPES 0 AND 1 ONLY. AS 3-5 BYTES WITH ALL 0XEF
RP3
	CSN_HI
	m_EEPROM_TO_NRF_REG		EE_RXP2_ADD_0, RX_ADDR_P2, NRF_RX_ADDR_P2
	m_EEPROM_TO_NRF_REG		EE_RXP3_ADD_0, RX_ADDR_P3, NRF_RX_ADDR_P3
	m_EEPROM_TO_NRF_REG		EE_RXP4_ADD_0, RX_ADDR_P4, NRF_RX_ADDR_P4
	m_EEPROM_TO_NRF_REG		EE_RXP5_ADD_0, RX_ADDR_P5, NRF_RX_ADDR_P5



#IFDEF DYNAMIC_PAYLOAD_LENGTH
;;SETUP PAYLOAD WIDTH FOR DATA PIPES 0 AND 1
		
	m_EEPROM_TO_NRF_REG		EE_DYNPD,	DYNPD,	NRF_DYNPD	;--ENABLE DYNAMIC PAYLOAD

	m_EEPROM_TO_NRF_REG		EE_FEATURE,	FEATURE,NRF_FEATURE	;--ENABLE DYNAMIC PAYLOAD, AND
		m_RD_NRF_REG		FEATURE,	NRF_FEATURE		
		
		;*******************************		;/Enable the W_TX_PAYLOAD_NOACK command
#ELSE
	FARCALL	SET_FIXED_PAYLOAD_LENGTHS
#ENDIF
		FARCALL		FLUSH_ALL
		BANKSEL	NRF_STATE_REG
		CLRF	NRF_STATE_REG

	RETURN

;*********************************************************************************************;
;	FUNCTION:	SET_FIXED_PAYLOAD_LENGTHS
;		PREREQ: COMPILES ONLY IF FIXED PAYLOAD LENGTH IS USED
;*********************************************************************************************;
#IFNDEF DYNAMIC_PAYLOAD_LENGTH
SET_FIXED_PAYLOAD_LENGTHS
		MOVLW			RX_PW_Px_VAL
		m_WTW_NRF_REG		RX_PW_P0
		MOVLW			RX_PW_Px_VAL
		m_WTW_NRF_REG		RX_PW_P1
		MOVLW			RX_PW_Px_VAL
		m_WTW_NRF_REG		RX_PW_P2
		MOVLW			RX_PW_Px_VAL
		m_WTW_NRF_REG		RX_PW_P3
		MOVLW			RX_PW_Px_VAL
		m_WTW_NRF_REG		RX_PW_P4
		MOVLW			RX_PW_Px_VAL
		m_WTW_NRF_REG		RX_PW_P5

		RD_NRF_REG		RX_PW_P0,	NRF_RX_PW_P0
		RD_NRF_REG		RX_PW_P1,	NRF_RX_PW_P1
		
		RD_NRF_REG		RX_PW_P2,	NRF_RX_PW_P2
		RD_NRF_REG		RX_PW_P3,	NRF_RX_PW_P3
		RD_NRF_REG		RX_PW_P4,	NRF_RX_PW_P4
		RD_NRF_REG		RX_PW_P5,	NRF_RX_PW_P5
 RETURN
#ENDIF
;*********************************************************************************************;
;*********************************************************************************************;


#ENDIF
